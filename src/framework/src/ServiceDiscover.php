<?php

declare(strict_types=1);

namespace Larmias\Framework;

use Larmias\Contracts\ApplicationInterface;
use Larmias\Di\AnnotationCollector;
use Larmias\Framework\Contracts\ServiceDiscoverInterface;

class ServiceDiscover implements ServiceDiscoverInterface
{
    /**
     * @var array|string[]
     */
    protected array $collect = [
        'Larmias\Process\Annotation\Process' => [
            'name' => ServiceDiscoverInterface::SERVICE_PROCESS,
            'method' => 'collectProcess',
        ],
        'Larmias\Command\Annotation\Command' => [
            'name' => ServiceDiscoverInterface::SERVICE_COMMAND,
            'method' => 'collectCommand',
        ],
    ];

    /**
     * @var array
     */
    protected array $services = [];

    /**
     * @param ApplicationInterface $app
     */
    public function __construct(protected ApplicationInterface $app)
    {
    }

    /**
     * @param \Closure $callback
     * @return void
     */
    public function discover(\Closure $callback): void
    {
        $pid = \pcntl_fork();
        if ($pid === -1) {
            throw new \RuntimeException('fork process error.');
        } else if ($pid === 0) {
            $this->handle();
            exit(0);
        }
        \pcntl_wait($status, \WUNTRACED);
        $callback();
    }

    /**
     * @param string $name
     * @param string $class
     * @param array $args
     * @return void
     */
    public function register(string $name, string $class, array $args = []): void
    {
        if (!isset($this->services[$name])) {
            $this->services[$name] = [];
        }
        $this->services[$name][] = ['class' => $class, 'args' => $args];
    }


    /**
     * @return array
     */
    public function services(): array
    {
        $file = $this->app->getRuntimePath() . 'services.php';
        if (\is_file($file)) {
            $this->services = \array_merge(require $file, $this->services);
        }
        return $this->services;
    }

    /**
     * @return void
     */
    protected function handle(): void
    {
        $this->app->initialize();
        $this->serviceProvider();
        $this->annotation();
        $header = '// This file is automatically generated at:' . \date('Y-m-d H:i:s') . \PHP_EOL . 'declare (strict_types = 1);' . \PHP_EOL;
        $content = '<?php ' . \PHP_EOL . $header . "return " . \var_export($this->services, true) . ';';
        \file_put_contents($this->app->getRuntimePath() . 'services.php', $content);
    }

    /**
     * @return void
     */
    protected function serviceProvider(): void
    {
        if (\is_file($path = $this->app->getRootPath() . 'vendor/composer/installed.json')) {
            $packages = \json_decode(\file_get_contents($path), true);
            // Compatibility with Composer 2.0
            if (isset($packages['packages'])) {
                $packages = $packages['packages'];
            }

            foreach ($packages as $package) {
                if (!empty($package['extra']['larmias']['providers'])) {
                    $providers = (array)$package['extra']['larmias']['providers'];
                    foreach ($providers as $provider) {
                        $this->register(ServiceDiscoverInterface::SERVICE_PROVIDER, $provider);
                    }
                }
            }
        }
    }

    /**
     * @return void
     */
    protected function annotation(): void
    {
        foreach (AnnotationCollector::all() as $item) {
            if (!isset($this->collect[$item['annotation']])) {
                continue;
            }
            $result = \call_user_func([$this, $this->collect[$item['annotation']]['method']], $item);
            $this->register($this->collect[$item['annotation']]['name'], $result['class'], $result['args']);
        }
    }

    /**
     * @param array $item
     * @return array
     */
    protected function collectProcess(array $item): array
    {
        return [
            'class' => $item['class'],
            'args' => [
                'name' => $item['value'][0]->name,
                'count' => $item['value'][0]->count,
            ]
        ];
    }

    /**
     * @param array $item
     * @return array
     */
    protected function collectCommand(array $item): array
    {
        return [
            'class' => $item['class'],
            'args' => [],
        ];
    }
}